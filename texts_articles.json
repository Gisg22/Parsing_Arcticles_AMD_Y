{
                                                                      "Поговорим о проблемах кэширования": "\n\n \nСуществует две главные проблемы программирования: именование переменных и инвалидация кэша. Поговорим о второй. Но для начала разберёмся с самим термином — кэширование. Я нашёл много определений, но мне они не очень нравятся. Приведу моё: Кэширование — от английского cacher (прятать, завёртывать), сохранение данных данных в другом месте или виде. Пункт, который меня смутил в других определениях — повсеместное упоминания ускорения. Но это не всегда так. Мы можем складывать данные и в более медленное хранилище, чтобы разгрузить основное. Тем самым уменьшив нагрузку на основной сторадж.  Можем преобразовать данные в вид более удобный для парсинга как то xml или json.  Можем разбрасывать данные по серверам, создавая дублирование, но при этом разгружая основное хранилище или перенося данные ближе к пользователю. Тем самым добавляем системе стабильность и удобство.\n\nТеперь о проблемах. Чаще всего мы сталкиваемся с проблемой времени кэширования. В сложных системах несколько уровней кэшей и закэшировано много разных данных и часто время кэширования для них указывается одинаковое или кратное (60m, 15m). Соответственно инвалидация происходит одновременно и в рамках одного запроса генерируется куча новых кэшей и приложение падает. Рецепт очень прост — добавлять к времени рандомную дельту, чтобы блоки кэшировались на разные промежутки времени. Приведу пример, но можно сделать удобнее, встроив расчёты в саму функцию кэширования.\n$cacheTime = 24 * 60 * 60; // кэшируем данные на целый день\n$delta = 60; // дельта отклонение во времени при перегенерации кэша \ncacheSet('Лента новостей', $dataTimeline, ($cacheTime + rand(0, $delta)));\ncacheSet('Топ 10 товаров', $dataTop10, ($cacheTime + rand(0, $delta)));\ncacheSet('Категори таваров', $dataCategories, ($cacheTime + rand(0, $delta)));\n\nЕщё один кейс — деплоймент нового кода. Зачастую он требует перегенерацию кэшей. Как правило у фреймворков есть консольные команды, которые прогревают кэш, плюс туда можно добавить свои, которые закэшируют основные данные, чтобы приложение не упало при первом же запросе.Можно найти решения, которые обходят нужные урлы или проходят по карте сайта, вот первый пример из поиска https://gitlab.elias-haeussler.de/eliashaeussler/cache-warmupРазумеется, это будет работать только если вы деплоите приложение отдельно, а не сразу на продакшене.\nНовый кэш генерируется не мгновенно. Можно использовать стратегию двух ключей. Тяжёлые данные кэшируются дважды с разными ключами, второй на большее время. Соответственно при запросе мы проверяем основной ключ , если его нет просим сгенерировать новый кэш, а сами берём данные из бэкапа. Пример статьи статья по теме.\n$key = 'ключ для кэша';\n$keyBackup = 'ключ для бэкапа';\nif (!($data = cacheGet($key))) {\n    $data = cashGet($keyBackup); // взяли старые данные\n    // асинхронно генерируем новые, чтобы не блокировать отдачу данных пользователю\n    cacheSetAsync($key, fn() => generateNewData());\n}\nreturn $data;\n\nГенерировать новые данные на лету вообще плохо, а ещё хуже, когда они генерируются многократно при параллельных запросах. Во избежания этого нужно использовать блокировки (пример на файлах), семафоры и т.д. в зависимости от ситуаций, только помните, что бэкэндов может быть несколько и тогда флаги лучше держать в redis или memcached. Лучше при этом использовать стратегию с кэшем бекапом, немного поменяв код выше.\n$key = 'ключ для кэша';\n$keyBackup = 'ключ для бэкапа';\nif (!($data = cacheGet($key))) {\n    $data = cashGet($keyBackup); // взяли старые данные\n    if (!cacheHasLock($key)) {\n        cacheSetLock($key);\n        // асинхронно генерируем новые, чтобы не блокировать отдачу данных пользователю\n        cacheSetAsync($key, fn() => generateNewData()); \n        // в конце generateNewData освобождаем блокировку cacheReleaseLock($key)\n    }\n}\nreturn $data;\n\nИзбыточное кэширование. Например, для списка новостей кэшируются записи целиком, включая заголовки, дату и полный текст новости, который как правило не используется, либо обрезается. \nКэшировать данные можно на разных уровнях кэша, где-то достаточно сохранить данные из базы, где-то модель целиком, где-то готовы html блок, а где-то страницу целиком. Важно не забывать о http кэшировании. Здесь можно почитать как это реализуется в Symfony, а так же какие заголовки посылать. Не стоит и забывать об инстументах для кэширования на уровнях серверов вроде Varnish.\nПрофилирование. Важно следить за кэшем, его объёмом, количеством попаданий-промахов, временем отклика. Бывает, что кэш лишь ворует ресурсы и даже негативно сказывается на производительности. Кэширование использует сеть, файловую систему, делает сериализацию и десериализацию — всё это не бесплатные операции, особенно на больших объектах.Но не стоит основываться на искусственных тестах на машине разработчиков. Количество данных может отличаться, эти данные будут попадать в свой кэш файловой системы или базы данных, не будет конкуренции и вымывания, сервер будет находиться под нагрузкой.\nПользуйтесь специализированными сервисами и профайлингом на продакшене. Но опять же помните о конкуренции, выборка пользователей может тормозить потому что слишком много ресурсов тратится на генерацию каталога товаров. Если что-то тормозит не надо сразу же бросаться чинить и подпирать это костылём из кэша, надо проверить почему это тормозит и тот ли код виноват.\nЭто далеко не все проблемы с кэшированием, но частые ошибки, которые упускают в реальных проектах. В итоге кэш протух, а новый сгенерироваться не может из-за резко возросшей единовременной нагрузки и блокировок. Либо кэша генерируется так много, что он становится неэффективным и замедляет систему не добавляя стабильности или удобства.\n\n\n\n",
                                                                      "Как исправить проблему с установкой viber в kubuntu 18.04": "\nВ новой версии kubuntu 18.04 используется libcurl4, а в зависимостях viber 3-я версия. Соответственно при установке viber просит установить старую версию и сносит новую libcurl4 и софт зависящий от неё. Лучший известный мне способ исправить данную проблему — пересобрать пакет.\nsudo su # переходим в режим root\ndpkg-deb -x viber.deb viber # распаковываем пакет скачанный с сайта viber\ndpkg-deb --control viber.deb viber/DEBIAN\nnano /DEBIAN/control # заменяем libcurl3 на libcurl4\ndpkg -b viber vibernew.deb # перепаковываем и устанавливаем\ndpkg -i vibernew.deb\nИ всё работает. Печалит то, что современные приоритеты месенджеров кроются в продажах стикеров и информации, а вот потратить пару человекочасов на нормальный способ дистрибуции — жалко.\n",
                                                                      "Рефакторинг блога.": "\nБложек немного приболел, дроплет на DO полетел, унеся с собой блог. Занимаюсь сейчас ремонтом и восстановлением из бэкапа. А заодно надо почистить лютый треш из стрых записей. А то многие статьи самому страшно перечитывать и хочется поломать руки тому говнокодеру…\n",
                                                                      "Недостатки laravel": "\nЯ очень люблю фреймворк laravel, пользуюсь им начиная с 3-й версии, тогда он был как глоток свежего воздуха на фоне zend и symfony. Уважаю Тейлора за проделанную работу, за принесённую в php фреймворки идею удобного апи и умение копировать лучшее из других фреймворков вроде RoR. О плюсах сказано уже много, но у него есть свои недостатки.\nЭти недостатки не фатальны, а некоторые и вовсе мои личные привычки, которые другим покажутся надуманными. Всё дерьмо вылитое ниже не сильно влияет на мою оценку laravel, который считаю лучшим фреймворком в мире PHP. И спасибо @kotchuprik и его статье, который подтолкнул высказаться и дал некоторые идеи.\nФасады и статика, они везде, даже в начале  проекта у вас уже в routes.php есть Route::get и это при наличии хорошего DI, который позволяет отказаться от этого и получить нормальный автокомплит в IDE. А так приходится ставить IDE Helper. Почему-то комментаторы набросились на этот пункт, начали меня оскорблять и учить, но недобитый фасад из коробки есть, я не виноват.\nНепоследовательность. Фреймворк очень долго переходил на PSR, но так до конца не перешёл. В папке database творится полный бардак. В app прямо в корне лежит моделька User. Роуты валяются в файлике app/Http/routes.php. Шаблоны расположены в директории resources, в отрыве от остального app. Предпочитаю когда есть директория с модулем, а уже в ней контроллеры, модели, шаблоны и т.д. А так получается каша, где все контроллеры свалены в кучу, с которой сложно работать на большом проекте. Сразу начинаешь оформлять код как пакеты, но появляется неудобство с прописыванием дополнительных путей для консольных команд.\nКонсольные команды и контроллеры почему-то разные сущности, при этом контроллеры вовсе отправлены в папку Http с роутингом и мидлеварами. Всегда считал что консоль должна работать так же как и при запросе из браузера и делал синтаксис.\nconsole news/1\n\nconsole user/1/store --method=post --data=\"name:Petja, login:God\"\nОтсутствие базовых классов для Model, как это есть для контроллеров, запроса, событий. А вот модельки при генерации наследуются от модели из вендора, что создаёт трудности с расширением, приходится править цепочку наследования после кодогенерации.\nВерсионирование. Между версиями большие изменения, при этом в минорных релизах умудраются убивать обратную совместимость, например, убрав метод list из моделей между 5.2 и 5.3, а не подождав до 6-й и там отрубив deprecated. Хотя сейчас есть LTS версия, но на ней мы уже ловили баг с роутингом, правда виной тому был вендорский пакет от symfony.\nЕсть древний принцип версионирования http://semver.org/lang/ru/, согласно ему минорная версия лишь добавляет функционал не ломая обратной совместимости.\nМиграции. Они до сих пор не по psr и без немспейсов, название класса не совпадает с именем файла из-за чего возникают коллизии. Например, у вас был раздел новости и таблица под него с миграцией\nphp artisan make:migration create_news_table --table=news\nСоздаст файл 2014_01_01_000000_create_users_table.php с классом CreateNewsTable, затем этот раздел убрали, а церез год вернули, но он уже работает по другим правилам и содержит другие поля\nphp artisan make:migration create_news_table --table=news\n2015_03_06_000000_create_users_table.php с тем же классом CreateNewsTable.\nОтладка. Из коробки отсутствует дебаг панель, её нужно устанавливать отдельно. Не очень хорошо подменён error_handler, из-за чего в дев режиме иногда видишь белую страницу и нужно лезть в логи, чтобы узнать что права на папку не прописал. В том же дев режиме почему-то не логируются запросы к БД, из нужно руками включать через те же фасады \\DB::enableQueryLog();\nElixir — не понимаю зачем Тейлор всунул из коробки эту нодовскую приблуду. Можно было прикрутить assetic или его аналоги, а там уже пусть разработчик через конфиги решает собирать ему всякие less c помощью php или node-ruby утилит. Assetic справляется с этими задачами, а проектах с большим количеством фронтенда всё равно пользуются webpack и grunt.\nФормы. Почему-то выбросили компонент для работы с формами, теперь приходится пользоваться LaravelCollective, который является сторонним компонентом, а сам фреймворк не поддерживает функционал необходимый в каждом веб приложении. Для REST формы не нужны, но как раз ради этого кейса Тейлор создал отдельный фреймворк Lumen. А так laravel проигрывает на фоне других фреймворков не имея решения для форм из коробки.\nEloquent работает со связанными таблицами не через джойны, а с помощью IN, это весьма неудобно если например нужно отсортировать данные по связанной таблице — новости по колличеству комментариев.\nТак же есть магические файндеры вроде where<field>(<value>) whereUsername(‘AmdY’), это очередной способ отстрелить себе ногу.\nМодель это мусорка в которое объеденились:\n1. Непосредственно сама модель и её методы, мутаторы\n2. Коллекции для работы с набором моделей, итерирование, сортировка, фильтрация и т.д.\n3. Построитель запросов select, where, take, get, all\n4. Пагинатор paginate, append\n5. Скоупы\n6. Менеджер подключений setConnection, onWriteConnection …\nМногие методы и атрибуты статические сообветсвенно распостраняются на все объекты класса.\n7. Связи hasOne, hasMany ….\n8. Observer и методы creating, created,deleting и т.д. При этом эти методы так же статические и задевают все модели\n9. Работа с event-ами\n10. Сериализация, при этом только json, стратегии нельзя задавать\nСкоупы, не понимаю зачем они нужны, они ломают автокомплит, вешаются на весь класс, а есть ещё глобальные скоупы.\nОтсутствие схем и возможности нормальной рефлексии для моделей, позволяющие строить автобилдеры для форм и списков, даже список связанных моделей нельзя получить.\nBlade. Непонятные вещи творятся с шаблонизатором, выбран очень странный путь его развитие с внедрением опасных конструкций  @inject и @php, следующим шагом будет @eval и @goto? При этом нет удобных средств для контроля цикла foreach, чтобы узнать первая-последняя итерация или её номер. Делать такое приходится через вставку php кода <?php $i++; ?>. Ну и отсутствие режима песочницы, из-за возможности использования php тегов а так же @php, @inject наши шаблоны опасны и нельзя делать безопасные шаблоны-темы, так как они подвержены php injection.\nУстановка пакетов. В laravel 3 бандлы можно было устанавливать из командной строки, сейчас же вам нужно:\n1. Зайти на документацию по пакету\n2. Добавить пакет через composer\n3. Прописать его в providers\n4. Добавить alias для фасадов. Так лучше не делать, но иногда фасады это единственный способ переопределять статик ад в пакетах.\n5. Импортнуть конфиги-вьюхи, миграции, сиды и т.д.\nДля 4-ки была идея специального установщика, но видимо она так и не попала в пятую.\nРоутинг.  Нужно прописывать все роуты вручную, исключения составляют ресурсы. Раньше был метод controller (в 5.2 deprecated, в master уже нет), который автоматически делал роуты для целого класса, но его убрали. Кроме того невозможно задать схему /module/controller/action, приходится делать специальный роут {module}/{controller?}/{action?} который всё это перехватывает и вручную инициализиуется контроллер и дёргается метод.\nТесты. Если у вас установлен глобально phpunit, то без бубна тесты им не запустятся. Очень бесило то, что не работали обсерверы в моделях при тестировании, сейчас это починили. Ну и не нравится очередной велосипед вместо проверенного Codeception.\nДокументация, в ней очень много примеров плохого кода, использование фасадов, отсутствие DI, замыкания для роутов. Учиться хорошему стилю новички должны на laracast, где часть уроков платная.\nПоддержка. В один прекрасный день Тейлор взял у убил все issue на github, такое отношения к багам пугает. LTS появилось очень поздно, лишь на версии 5.1. Ну и развитие идёт по пути того, что надо авторам для их проекта, а не под нужды сообщества.\nДжуниоры. Свой кажущейся простотой фреймворк привлекает кучу новичков, которые не могут освоить даже документацию к фреймворку, composer, разобраться с автозагрузчиком и научиться устанавливать document root. Вот типичный пример таких джуниоров, которые даже синтаксиса языка не знают.\np.s. Подбрасывайте ещё недостатки, буду добавлять их в статью чтобы собрать в одном месте, а не ныть постоянно по мелочам.\n\n",
                                                                      "Проблемы с обновлением ubuntu": "\nНедавно на kubuntu 14.10 столкнулся с проблемой при обновлении\nОш http://by.archive.ubuntu.com utopic-backports/main Sources\n\n404 Not Found\n\nОш http://by.archive.ubuntu.com utopic-backports/restricted Sources\n\n404 Not Found\n\nОш http://by.archive.ubuntu.com utopic-backports/universe Sources\n\n404 Not Found\n\nОш http://by.archive.ubuntu.com utopic-backports/multiverse Sources\n\n404 Not Found\n\nОш http://by.archive.ubuntu.com utopic-backports/main i386 Packages\n\n404 Not Found\n\nОш http://by.archive.ubuntu.com utopic-backports/universe i386 Packages\n\n404 Not Found\n\nОш http://by.archive.ubuntu.com utopic-backports/multiverse i386 Packages\n\n404 Not Found\n\nВ кэше http://by.archive.ubuntu.com utopic-backports/main Translation-en\n\nВ кэше http://by.archive.ubuntu.com utopic/restricted Translation-ru\nДолго не мог найти решение, но всё же нарыл в очередной заход\nsudo -i\n\napt-get clean\n\ncd /var/lib/apt\n\nmv lists lists.old\n\nmkdir -p lists/partial\n\napt-get clean\n\napt-get update\nСпасибо автору коммента Mete.\n",
                                                                      "Continuous Integration, delivery, deployment": "\nДанный пост противопоказан и может оскорблять чувства верующих в церковь Мартина Фаулера, так как является довольно вольной трактовкой, но обтесанной годами моей практики.\nСидит программист, пишет свой код, думает о пиве и здесь появляется другой программист, с ним тестировщик и, прости Господи, проектный менеджер. Здесь уже не до пива, код больше нельзя править на сервере через удалённый доступ. Приходится разворачивать git, лепить ветки, создавать билды и гонять тесты и в дело вступает супергерой Continuous. Последнее время принято мешать три шага Continuous в одну кучу, хотя эти шаги сильно отличаются по целям и подходам. Эти шаги — Continuous Integration, Continuous Delivery и Continuous Deployment.\nContinuous Integration — интеграция вашего кода c общим репозиторием. После того как вы совершаете коммит-пуш, система видит его, делает билд, запускает unit тесты и собирает разную статистику о качестве, покрытии и метрики кода. После этого в интерфейсе системы мы может просмотреть всё собранное. В качестве сервера CI можно использовать прожёрливый но удобный Jenkins (Java) или провославный, но сырой PHPCI (PHP). Очень часто грешат тем, что не контролируют эти самые метрики, доверяя только code review. Например, phpmetrics не только всё считает, но и рисует графики, где визуально можно заметить проблемы на проекте. Из-за того, что мы гоняем только unit тесты, то билд получается простой, все происходит почти мгновенно, можно делать даже на машине разработчика, а уже по итогам делать пуш на сервер. Так что программист может и должен коммитить сколько угодно раз на день.\n\n\nContinuous Delivery — непрерывная доставка. Развёртывание проекта на веб сервере, чтобы его могли посмотреть тестировщики, погонять функциональные, интеграционные, нагрузочные и прочие тесты. Этот билд является довольно тяжёлым и долгим, нам нужна полноценная и заполненная фикстурами база данных, нужны дополнительные ассеты, вроде картинок товаров или видео для скачивания. Потому данный шаг не так часто делается, а только после CI, иногда только по ночам, а бывает даже запускается не в автоматическом режиме.\nContinuous deployment — деплоймент на боевые сервера. Важным отличием от предыдущего шага является понимание того, что билд может не пройти или результат на реальных данных будет неверный, потому нужно быть готовым к откату. Здесь на помощь приходят утилиты вроде capistrano (Ruby) или rocketeer (PHP). Они создают разворачивают каждый релиз в отдельной директории, переключая текущий, который по сути является ссылкой на один из релизов.\nRocketeer штука очень полезная и годиться для первых двух этапов, особенно, если вы не используете фиче бранчи и валите все правки в один stage-prelive. Тогда в случае проваленных тестов он сделает revert для последних правок и rollback для релиза. Помимо этого его можно использовать как task runner, как и наоборот — с помощью task runner можно делать deploy. Так как последнее время у некоторых разработчиков проблемы с поиском php based утилит, то посоветую Robo, не вкручивайте, пожалуйста, всякие gulp или elixir.\nВроде ничего не забыл, шаги очень простые и настроив один раз вы сможете внедрять всю цепочку в новые проекты менее чем за день без специально обученных людей. В интернете можно найти сервисы, где все уже работает, но я не советую ими пользоваться, нужно хотя бы раз самому разобраться, да и дополнительная гибкость рано или поздно вам понадобится.\n",
                                                                      "Модули в angularjs": "\nПоговорим о повторно используемом коде. Чтобы код повторно использовать его нужно оформлять особым способом и выносить в пакеты. Сейчас все нормальные фреймворки в разных языках программирования имеют поддержку пакетов и пакетные менеджеры для управления ими, а так же для решения проблем с версиями и зависимостями. В javascript для управления пакетами применяется bower. Теперь же рассмотрим как писать код, чтобы его можно было внедрять в проекты, в качестве препарируемого будет angularjs.\nAngularjs поддерживает модули, будем использовать именно их. Для примера можно разворатить пару готовых, я же постараюсь описать найденное мною. Модуль является контейнер в который мы можем складывать константы, переменные, контроллеры, сервисы и т.д., далее мы просто подключаем js файл и при создании модуля приложений добавляем свой модуль в зависимости.\nangular.module('myModule', [])\n\n  .value('bar', 123).;\n\nangular\n\n  .module('appModule', ['myModule'])\nТеперь в модуле appModule будет доступно все из myModule, это довольно печальный факт, т.к. не продумали даже неймспейсов для избавления от коллизий с именованием. Т.е. переменная bar будет доступна именно по своему имени bar, хотелось бы что-то вроде myModule.bar. Потому в целях борьбы с этим старайтесь создавать модули на каждый чих, чтобы разом в скоуп не забрасывать все содержимое. Например, можно создавать модули отдельно для контроллеров, сервисов, директив или дробить модуль на части по функционалу.\nangular.module('myModule.controllers', [])\n\n  .controller(...)\n\n  .controller(...);\n\nangular.module('myModule.services', [])\n\n  .service(...)\n\n  .service(...);\n\nangular.module('appModule', ['myModule.controllers', 'myModule.services'])\nangular.module('myModule.blog', [])\n\n  .controller(...)\n\n  .service(...)\n\n  .directive(...);\n\nangular.module('myModule.catalog', [])\n\n  .controller(...)\n\n  .service(...)\n\n  .directive(...);\n\nangular.module('appModule', ['myModule.blog', 'myModule.catalog'])\nК сожалению это всё что имеется у меня по данной теме, теперь покажу пример такого модуля. Как самый часто используемый я взял авторизацию и проверку прав. Набросал довольно простой модуль. Суть такова: при описании роутоу мы добавляем аттрибут access и если он есть, то проверяем залогинен ли пользователь. Для отлавливания момента смены роута вешаем событие на $rootScope.$on(‘$routeChangeStart’, …). Ну и пару методов для авторизации и её сброса.\n(function (windows, angular) {\n\n  'use strict';\n\n  angular.module('amdyAuth', [])\n\n    .factory('UserService', ['$rootScope', '$http', function ($rootScope, $http) {\n\n      var self = {\n\n        config: {\n\n          urlLogin: '/login',\n\n          urlLogout: '/logout',\n\n          urlRedirect: '/'\n\n        },\n\n        isLogged: false,\n\n        user: {},\n\n        run: function (userConfig) {\n\n          angular.extend(this.config, userConfig);\n\n          $rootScope.$broadcast('UserService:run', this);\n\n          $rootScope.$on('$routeChangeStart', function (event, next, current) {\n\n            if (next.auth && !self.isLogged) {\n\n              next.resolve = null;\n\n              next.redirectTo = self.config.urlRedirect;\n\n              event.preventDefault();\n\n            }\n\n          });\n\n        },\n\n        logout: function () {\n\n          $rootScope.$broadcast('UserService:logout');\n\n          this.clear();\n\n          return $http.get(this.config.urlLogout);\n\n        },\n\n        clear: function () {\n\n          this.isLogged = false;\n\n          this.user = {};\n\n        },\n\n        login: function (data) {\n\n          $rootScope.$broadcast('UserService:login', data);\n\n          return $http.post(this.config.urlLogin, data)\n\n            .success(function (data, status, headers, config) {\n\n              self.isLogged = true;\n\n              self.user = data;\n\n              $rootScope.$broadcast('UserService:login:success', data);\n\n            })\n\n            .error(function (data, status, headers, config) {\n\n              $rootScope.$broadcast('UserService:login:error', data);\n\n            });\n\n        }\n\n      };\n\n      return self;\n\n    }]);\n\n})(window, window.angular)\n\n\nКак видно, создал модуль amdyAuth и в нем одну фабрику порождающий наш сервис UserService. Завёл переменную self, чтобы обращаться к объекту в callback-ах. Для конфигурирования создал конфиг, который затем можно переопределять при вызове метода run, где навешивается наше событие на смену роута. Так же для событий по смене состояний постоянно делаю broadcast, чтобы модуль можно было расширять без влезания в его код. Функционала минимум.\nТеперь посмотрим его использование.\n(function (windows, angular) {\n\n  'use strict';\n\n  angular.module('appModule', [\n\n    'ngRoute',\n\n    'amdyAuth'\n\n  ]).config(['$routeProvider', '$locationProvider', '$httpProvider', function ($routeProvider, $locationProvider, $httpProvider) {\n\n    $routeProvider.when('/', {controller: 'IndexController', templateUrl: '/app/_index.html'})\n\n      .when('/public', {controller: 'PublicController', templateUrl: '/app/_public.html'})\n\n      .when('/admin', {controller: 'AdminController', templateUrl: '/app/_admin.html', auth: true})\n\n      .otherwise({redirectTo: '/'});\n\n  }]).run(['UserService', '$rootScope', function (UserService, $rootScope) {\n\n    $rootScope.$on('UserService:run', function (e, data) {\n\n      console.info('UserService:run', data);\n\n    });\n\n    $rootScope.$on('UserService:login', function (e, data) {\n\n      console.info('UserService:login', data);\n\n    });\n\n    $rootScope.$on('UserService:login:success', function (e, data) {\n\n      console.info('UserService:login:success', data);\n\n    });\n\n    $rootScope.$on('UserService:login:error', function (e, data) {\n\n      console.info('UserService:login:error', data);\n\n    });\n\n    $rootScope.$on('UserService:logout', function (e, data) {\n\n      console.info('UserService:logout', data);\n\n    });\n\n    UserService.run({urlLogin: 'login.json', urlLogout: \"login.json\"});\n\n  }]).controller('MainController', ['$scope', 'UserService', '$location', function ($scope, UserService, $location) {\n\n    $scope.userService = UserService;\n\n    $scope.logout = function () {\n\n      UserService.logout();\n\n      $location.path('/');\n\n    }\n\n  }]).controller('IndexController', ['$scope', 'UserService', function ($scope, UserService) {\n\n    $scope.login = '';\n\n    $scope.password = '';\n\n    $scope.userService = UserService;\n\n    $scope.doLogin = function () {\n\n      UserService.login({login: $scope.login, password: $scope.password});\n\n    }\n\n  }]).controller('PublicController', [function () {\n\n  }]).controller('AdminController', [function () {\n\n  }])\n\n  ;\n\n})(window, window.angular);\n\n\nПодключил свой модуль, после чего в методе run повесил слушетелей на наши события и вызвал метод UserService.run({urlLogin: ‘login.json’, urlLogout: «login.json»}); переопределяя переменные конфига. Для роута /admin указал что нужно проверять права auth: true.\nРезультат можно посмотреть забрать с гитхаба https://github.com/AmdY/blog-angular-modules\nТеперь немного о модулях. Созданый модуль нужно выносить в отдельный репозиторий, добавлять в него bower.json и регистрировать, чтобы можно было использовать в других проектах. В попытках найти готовые модули я набрёл на один выживший проект http://ngmodules.org/. В больше тысячи зарегистрированных модулей, а вот статистика лайков удручает, у самого популярного всего 402, а с сотней не наберётся и десятка. Люди предпочитают велосипедить, хотя есть довольно полезные модули. Но при этом нормальной авторизации, который легко бы интегрировался с laravel я не нашёл, постараюсь докрутить до продакшен состояния этот.\np.s. Покритикуйте код, а то в javascript я далеко не гуру и стиль по старинке, как под IE6.\n \n",
                                                                      "Итоги 2014": "\nВ 2014 году в блоге не появилось ни одной новой записи, но помню про него, копится материал, появилась парочка черновиков и в 2015 обязательно разрожусь целым циклом постов. Год получился отличным, есть о чём рассказать.\nПомимо написания кода, активно начал заниматься обучением: появилась стажёрская программа, организуем воркшопы внутри компании, готовим небольшой хакатон, провел тьму собеседований. Приятно наблюдать как это всё приносит результаты, да ещё быстрее чем планировалось. Огромное спасибо за это HR и просто отличному человеку Ольге Бобко, которая дала возможность и подталкивает в этом направлении.\nА вот за код мне стыдно, он становится всё более пахнущим, работа в команде и бизнес требования уводят всё дальше от мечты перфекциониста. Помимо веб проектов поучавствовал в разработке приложения для телевизионной приставки и магазинного терминала, php и javascript открывают все больше граней и сфер применения, что не может не радовать. Осваиваю разработку под windows phone, С# отличный язык, но WinJS всё же привычнее.\nС наступающим Новым годом! Желаю всем отличных проектов, чтобы о коде и паттернах думалось меньше, чем об отдыхе, пейте пиво, играйте в футбол, любите жизнь.\n\n",
                                                                      "Continuous integration с Jenkins": "\nContinuous integration или непрерывная интеграция — это практика создания  автоматизированной сборки проекта. Хотя это и звучит как-то заковыристо, но это то, что программист делает ежедневно. Мы пишем код и проверяем его на синтаксические ошибки, на соответствие стилю кодирования, прогоняем тесты, боремся с copy-past и тд. и т.п. В PHP существует масса инструментов. позволяющих это автоматизировать, в PEAR есть пакет phpqatools, который ставит сразу пачку таких утилит. Но прогонять их руками неудобно, к тому же хочется иметь какой-то графический интерфейс, чтобы просматривать отчёты, чтобы наблюдать как изменяется проект, иметь возможность смотреть на старые версии и т.д. Здесь на помощь приходит Jenkins.Jenkins не единственный инструмент, но он открыт и бесплатен и Sebastian Bergmann подготовил всё для интеграции его с PHP. Открываем Template for Jenkins Jobs for PHP Projects, там практически всё написано, я лишь перескажу и покажу чуть адаптированный вариант.\nСтавим набор утилит для анализа кода\npear config-set auto_discover 1\n\npear install pear.phpqatools.org/phpqatools pear.netpirates.net/phpDox\nЗатем ставим ant и jenkins, последний лучше брать самый свежий с официального сайта\nдобавляем в /etc/apt/sources.list\n\n#Jenkins\n\ndeb http://pkg.jenkins-ci.org/debian binary/\n\n\n\nsudo apt-get update\n\nsudo apt-get install ant jenkins\nКогда Jenkins установлен, он доступен по адресу http://localhost:8080/, рулить им можно через сервис service jenkins (start|stop….)\nТеперь нужно добавить плагины, для этого можно воспользоваться либо веб интерфейсом, а удобнее через cli.\nwget http://localhost:8080/jnlpJars/jenkins-cli.jar\n\n\n\njava -jar jenkins-cli.jar -s http://localhost:8080 install-plugin \\\n\ncheckstyle cloverphp dry htmlpublisher jdepend plot pmd violations xunit\n\n\n\njava -jar jenkins-cli.jar -s http://localhost:8080 safe-restart\nТеперь можно составлять свой шаблон отчётов, а лучше воспользоваться готовым \ncurl https://raw.github.com/sebastianbergmann/php-jenkins-template/master/config.xml | \\\n\n    java -jar jenkins-cli.jar -s http://localhost:8080 create-job php-template\nТеперь, зайдя в панель Jenkins, вы увидите наш шаблон проекта, но его использовать не стоит, а нужно создать новый проект, скопировав его с php-template\nВ описании проекта картинки svg, их не убирайте, после удачной сборки они будут отображать статистику в виде графиков. Вам нужно указать источник данных, в моём случае это локальный git репозиторий. Важная деталь — jenkins пытается создать тег для сборки, я эту функцию отключаю. На скриншоте показана кнопка расширенных настроек, там нужно отметить чекбокс Skip internal tag.\n\n \nЗатем настраиваем наш ant, чтобы он генерировал отчёты. У меня билд скрипт находится по пути build/build.xml и вызываю дефолтный джоб build. Вы можете скачать готовый скрипт от Себастьяна, его нужно класть в корень проекта. Я предпочёл вынести все настройки в отдельную папку build, пример jenkins-sample выложил на github.\n\n \nМожете указать этот пример в качестве источника и получите билд, желательно, с синим кружочком.\n\n \nТак же доступна обширная статистика по качеству кода, тестам и сравнение с предыдущими сборками.\n\n \nРезюме. Получилось довольно коротко, так и есть на самом деле, CI внедряется очень легко и быстро. Можно брать пример моего проекта и модифицировать его под свои, самое важное, это управлять include-exclude директориями для утилит. Можно даже запускать ant без jenkins — ant -f build/buils.xml build.\np.s. Буду вносить правки в проект, для более удобного конфигурирования, так что следите за проектом.\n",
                                                                      "ORDER BY FIELD в Laravel": "\nЕсть замечательная SQL конструкция, позволяющая задавать свой порядок сортировки для ORDER BY. Сегодня мне понадобилось использовать ORDER BY FIELD(priority, 2,1,3), ситуация осложнялась тем, что используется ORM от Laravel и его Query Builder экранирует то. что передано через ->orderBy. Решение же оказалось очень простым, нужно использовать raw\n\\Model::orderBy( \\DB::raw('FIELD(status, 2, 1, 3)') );\n"
}